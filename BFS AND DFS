CODE:
Implementation of BFS using adjacency matrix.

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX 5

void addVertex(char);
void addEdge(int, int);
void displayVertex(int);
void depthFirstSearch();
int getAdjUnvisitedVertex(int);

struct Vertex {
   char label;
   bool visited;
};

//stack variables
int stack[MAX];
int top = -1;

//graph variables
//array of vertices
struct Vertex * lstVertices[MAX];
//adjacency matrix
int adjMatrix[MAX][MAX];
//vertex count
int vertexCount = 0;

//stack functions
void push(int item) {
   stack[++top] = item;
}

int pop() {
   return stack[top--];
}

int peek() {
   return stack[top];
}

bool isStackEmpty() {
   return top == -1;
}

//graph functions
//add vertex to the vertex list
void addVertex(char label) {
   struct Vertex * vertex = (struct Vertex * ) malloc(sizeof(struct Vertex));
   vertex -> label = label;
   vertex -> visited = false;
   lstVertices[vertexCount++] = vertex;
}

//add edge to edge array
void addEdge(int start, int end) {
   adjMatrix[start][end] = 1;
   adjMatrix[end][start] = 1;
}

//display the vertex
void displayVertex(int vertexIndex) {
   printf("%c ", lstVertices[vertexIndex] -> label);
}

//get the adjacent unvisited vertex
int getAdjUnvisitedVertex(int vertexIndex) {
   int i;
   for (i = 0; i < vertexCount; i++) {
      if (adjMatrix[vertexIndex][i] == 1 && lstVertices[i] -> visited == false) {
         return i;
      }
   }
   return -1;
}

void depthFirstSearch() {
   int i;
   
   //mark first node as visited
   lstVertices[0] -> visited = true;
   
   //display the vertex
   displayVertex(0);
   
   //push vertex index in stack
   push(0);
   
   while (!isStackEmpty()) {
      //get the unvisited vertex of vertex which is at top of the stack
      int unvisitedVertex = getAdjUnvisitedVertex(peek());
      //no adjacent vertex found
      if (unvisitedVertex == -1) {
         pop();
      } else {
         lstVertices[unvisitedVertex] -> visited = true;
         displayVertex(unvisitedVertex);
         push(unvisitedVertex);
      }
   }
   
   //stack is empty, search is complete, reset the visited flag
   for (i = 0; i < vertexCount; i++) {
      lstVertices[i] -> visited = false;
   }
}

int main() {
   int i, j;
   for (i = 0; i < MAX; i++) // set adjacency {
      for (j = 0; j < MAX; j++) // matrix to 0
         adjMatrix[i][j] = 0;
   
   addVertex('S'); // 0
   addVertex('A'); // 1
   addVertex('B'); // 2
   addVertex('C'); // 3
   addVertex('D'); // 4
   
   addEdge(0, 1); // S - A
   addEdge(0, 2); // S - B
   addEdge(0, 3); // S - C
   addEdge(1, 4); // A - D
   addEdge(2, 4); // B - D
   addEdge(3, 4); // C - D
   
   printf("Depth First Search: ");
   depthFirstSearch();
   
   return 0;
}


Implementation of DFS using adjacency matrix.

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX 5

struct Vertex {
    char label;
    bool visited;
};

// Graph variables
struct Vertex *lstVertices[MAX];
int adjMatrix[MAX][MAX];
int vertexCount = 0;

// Queue variables
int queue[MAX], front = 0, rear = -1;

// Function declarations
void addVertex(char label);
void addEdge(int start, int end);
void displayVertex(int vertexIndex);
void breadthFirstSearch();
bool isQueueEmpty();
void enqueue(int item);
int dequeue();

void addVertex(char label) {
    struct Vertex *vertex = (struct Vertex *)malloc(sizeof(struct Vertex));
    vertex->label = label;
    vertex->visited = false;
    lstVertices[vertexCount++] = vertex;
}

void addEdge(int start, int end) {
    adjMatrix[start][end] = 1;
    adjMatrix[end][start] = 1; // Undirected graph
}

void displayVertex(int vertexIndex) {
    printf("%c ", lstVertices[vertexIndex]->label);
}

bool isQueueEmpty() {
    return front == (rear + 1) % MAX;
}

void enqueue(int item) {
    rear = (rear + 1) % MAX;
    queue[rear] = item;
}

int dequeue() {
    int data = queue[front];
    front = (front + 1) % MAX;
    return data;
}

void breadthFirstSearch() {
    lstVertices[0]->visited = true;
    displayVertex(0);
    enqueue(0);

    while (!isQueueEmpty()) {
        int currentVertex = dequeue();
        for (int i = 0; i < vertexCount; i++) {
            if (adjMatrix[currentVertex][i] == 1 && !lstVertices[i]->visited) {
                lstVertices[i]->visited = true;
                displayVertex(i);
                enqueue(i);
            }
        }
    }

    // Reset visited flags
    for (int i = 0; i < vertexCount; i++) {
        lstVertices[i]->visited = false;
    }
}

int main() {
    for (int i = 0; i < MAX; i++) 
        for (int j = 0; j < MAX; j++) 
            adjMatrix[i][j] = 0;

    addVertex('S'); // 0
    addVertex('A'); // 1
    addVertex('B'); // 2
    addVertex('C'); // 3
    addVertex('D'); // 4

    addEdge(0, 1); // S - A
    addEdge(0, 2); // S - B
    addEdge(0, 3); // S - C
    addEdge(1, 4); // A - D
    addEdge(2, 4); // B - D
    addEdge(3, 4); // C - D

    printf("Breadth First Search: ");
    breadthFirstSearch();

    return 0;
}
